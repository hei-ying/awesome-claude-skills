# Liteflow - Getting Started

**Pages:** 2

---

## 🍤LiteFlow简介

**URL:** https://liteflow.cc/pages/5816c5/

**Contents:**
- 🍤LiteFlow简介
- # 前言
- # LiteFlow框架的优势
- # LiteFlow的设计原则
- # LiteFlow不适用于哪些场景
- # LiteFlow适用于哪些场景

在每个公司的系统中，总有一些拥有复杂业务逻辑的系统，这些系统承载着核心业务逻辑，几乎每个需求都和这些核心业务有关，这些核心业务业务逻辑冗长，涉及内部逻辑运算，缓存操作，持久化操作，外部资源调取，内部其他系统RPC调用等等。时间一长，项目几经易手，维护成本就会越来越高。各种硬代码判断，分支条件越来越多。代码的抽象，复用率也越来越低，各个模块之间的耦合度很高。一小段逻辑的变动，会影响到其他模块，需要进行完整回归测试来验证。如要灵活改变业务流程的顺序，则要进行代码大改动进行抽象，重新写方法。实时热变更业务流程，几乎很难实现。

如何打破僵局？LiteFlow为解耦逻辑而生，为编排而生，在使用LiteFlow之后，你会发现打造一个低耦合，灵活的系统会变得易如反掌！

LiteFlow是一个非常强大的现代化的规则引擎框架，融合了编排特性和规则引擎的所有特性。

如果你要对复杂业务逻辑进行新写或者重构，用LiteFlow最合适不过。它是一个编排式的规则引擎框架，组件编排，帮助解耦业务代码，让每一个业务片段都是一个组件。

利用LiteFlow，你可以将瀑布流式的代码，转变成以组件为核心概念的代码结构，这种结构的好处是可以任意编排，组件与组件之间是解耦的，组件可以用脚本来定义，组件之间的流转全靠规则来驱动。LiteFlow拥有开源规则引擎最为简单的DSL语法。十分钟就可上手。

组件可实时热更替，也可以给编排好的逻辑流里实时增加一个组件，从而改变你的业务逻辑。

LiteFlow的脚本组件，支持众多脚本语言，完全和Java打通，你可以用脚本来实现任何逻辑。

LiteFlow支持把编排规则和脚本放在数据库，注册中心中，还有可以任意扩展的接口，方便你定制。

我们的编排语法强大到可以编排出任何你想要的逻辑流程，你有想过，要在代码中实现下面这种复杂逻辑流程该如何实现吗？

我相信肯定有人能实现，但是是需要付出一定的开发成本的。

而以上这一切，利用LiteFlow，轻而易举，你立马唾手可得！

LiteFlow是基于工作台模式进行设计的，何谓工作台模式？

n个工人按照一定顺序围着一张工作台，按顺序各自生产零件，生产的零件最终能组装成一个机器，每个工人只需要完成自己手中零件的生产，而无需知道其他工人生产的内容。每一个工人生产所需要的资源都从工作台上拿取，如果工作台上有生产所必须的资源，则就进行生产，若是没有，就等到有这个资源。每个工人所做好的零件，也都放在工作台上。

这个模式映射到LiteFlow框架里，工人就是组件，工人坐的顺序就是流程配置，工作台就是上下文，资源就是参数，最终组装的这个机器就是这个业务。正因为有这些特性，所以LiteFlow能做到统一解耦的组件和灵活的装配。

LiteFlow自开源来，经常有一些小伙伴来问我，如何做角色任务之间的流转，类似于审批流，A审批完应该是B审批，然后再流转到C角色。

这里申明下，LiteFlow只做基于逻辑的流转，而不做基于角色任务的流转。如果你想做基于角色任务的流转的工作流，推荐使用：

flowlong (opens new window)

真正的国产工作流引擎，json 格式实例模型、简易审批流程设计器、为中国特色审批匠心打造

以及flowable (opens new window)这两个框架。

LiteFlow适用于拥有复杂逻辑的业务，比如说价格引擎，下单流程等，这些业务往往都拥有很多步骤，这些步骤完全可以按照业务粒度拆分成一个个独立的组件，进行装配复用变更。使用LiteFlow，你会得到一个灵活度高，扩展性很强的系统。因为组件之间相互独立，也可以避免改一处而动全身的这样的风险。

---

## 🫕快速解析模式

**URL:** https://liteflow.cc/pages/5fe959/

**Contents:**
- 🫕快速解析模式

LiteFlow提供了一个liteflow.fast-load的配置参数：

如果把这个设为true，则在拥有超大量的规则的时候，加载性能能提高4倍。

这里超大量规则指的是5000条规则以上。如果几百个规则，还是推荐用默认模式。

我并不推荐所有的人把快速load模式打开，因为快速load模式牺牲了热更新时的平滑性。换句话说就是，在正常模式下，如果当你热更新时正好有正在执行的流程，那么正在执行的流程是会用老的链路的，只有下一次才会用最新的链路。如果你打开了快速load模式，那么在热更新时，正好在执行过程中的流程有可能前半部分是老的流程，而后半部分有可能读到新的流程。这样就造成了不一致了。

当然这种场景是非常极端的场景，在普通的场景中，可能根本也不需要保持热更新时的平滑性。所以fast-load模式是有代价的。鱼和熊掌不可兼得。看项目要求了。

← 🧁自定义请求Id 🌭不同格式规则加载→

**Examples:**

Example 1 (properties):
```properties
liteflow.fast-load=false
```

---
